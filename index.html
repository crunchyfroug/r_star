<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
    <meta charset="UTF-8">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="index.js" charset="utf-8"></script>
</head>
<body>
    <div id="dates">
        <br>
        <input id="begin" type="date">
        <input id = "end"  type="date">
    </div><br>
    <div id="buttons">
        
        <button type="button" name="submit" onclick="searchData()">Search</button>
        <button type="button" name="clear" onclick="clearDates()">Clear dates</button>
    </div>
    <div id="price_fall"></div>
    <div id="container">
    </div>
</body>
<script>
    function clearDates(target) {
        begin.value="";
        end.value="";
        
        
    }
    function searchData () {

        // every time new search is made, clear the page of previous data
        document.getElementById("container").innerHTML="";
        document.getElementById("price_fall").innerHTML="";

        // get dates from input, convert them to epoch and search values API 
        var startDate = document.getElementById("begin").value;
        var endDate = document.getElementById("end").value;

        var unixStart = new Date(startDate).getTime() / 1000.0;
        var unixEnd = new Date(endDate);
        unixEnd.setHours(unixEnd.getHours() + 24)
        unixEnd = unixEnd.getTime() /1000.0

        api_url = `https://api.coingecko.com/api/v3/coins/bitcoin/market_chart/range?vs_currency=eur&from=${unixStart}&to=${unixEnd}`;
   
    
     

        $.getJSON(api_url, function(data) {

            //map through the object and save values into 3 separate arrays

            const price_container = data.prices.map(([time, price]) => {
                return [time,price];
            });

            const marketcap_container = data.market_caps.map(([time, cap]) => {
                return [time, cap];
            });
            const volumes_container = data.total_volumes.map (([time, volumes]) => {
                return [time, volumes]
            });

            //uses x as index for deletion, if date value changes, index is increased +1
            //checks if the 3 arrays' time values equal to another
            //insert data from arrays to one combined array
            var fullArr = [];
            var x = 1;

            for (var  i = 0; i < price_container.length;i++) {
                try {
                    if (price_container[i][0] == marketcap_container[i][0] && marketcap_container[i][0] == volumes_container[i][0])
                    {
                        var date = new Date(price_container[i][0]).toUTCString();
                        date = date.substring(0, date.length - 13)
                        fullArr.push([date, price_container[i][1], marketcap_container[i][1], volumes_container[i][1]]);           
                        if (i != 0) {
                            //change epoch into parsed timestamp and check 2 days values, if same value next is removed

                            var currentDate = new Date(fullArr[x][0]).toUTCString();
                            var previousDate = new Date(fullArr[x-1][0]).toUTCString();  
        
                            if (currentDate == previousDate) {
                                fullArr.splice(x,1);
                            } 
                            else {
                                x++;
                            }     
                        }
                    }
                } catch {
                        
                    console.log("messed up")
                }  

        }
        console.log(fullArr);
        var fall = 0;
        var check = 0;
        var highest_volume = 0;
        var day = "";

        for (var i = 0; i < fullArr.length;i++) {
            //checks how many days in a row price has decreased, check tracks how many days in a row
            //fall stores the highest price decrease in a row 
            //second if tracks the highest volume between given dates
            //first days volume recorded in catch
            try {
                if (fullArr[i][1] < fullArr[i-1][1]) {
                    check++;
                    if (check > fall) {
                        fall = check;
                    }

                } else if (fullArr[i][1]> fullArr[i-1][1]){
                    check = 0;
                }

                if (fullArr[i][3] > highest_volume) {
                    highest_volume = fullArr[i][3]
                    day = fullArr[i][0] 
                }

                }
            
            catch {
                highest_volume = fullArr[i][3];
                console.log("error")
            }
                        
            //write days and values to html one by one
            document.getElementById("container").innerHTML += 
            "<br> Day: " + fullArr[i][0] + "<br> Price: " + fullArr[i][1] + "<br> Market cap: " + 
            fullArr[i][2] + "<br> Total volume: " + fullArr[i][3] + "<br>";
            }
            //on top of the page, write highest row and biggest volume of all dates
            document.getElementById("price_fall").innerHTML += "<br>Price has decreased for " + fall + " days in a row" +
            " for the inputs from " + startDate + " and to " + endDate + "<br><br>" +
            day+" with the highest trading volume: " + Number((highest_volume).toFixed(1)).toLocaleString() + "â‚¬";
    });

}

</script>
</html>